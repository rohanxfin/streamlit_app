
d = {'Honda': {'Amaze': ['1.2 S i-VTEC[2013-2016]', 'VX CVT 1.2 Petrol [2021]'],
  'BR-V': ['V CVT Petrol'],
  'Brio': ['S MT', 'VX AT'],
  'City': ['1.5 V MT[2011-2014]', 'E[2014-2017]', 'ZX Petrol CVT'],
  'Jazz': ['S Petrol[2015-2018]', 'V', 'V Petrol[2015-2018]'],
  'Mobilio': ['S Petrol'],
  'WR-V': ['VX MT Diesel',
   'VX MT Diesel[2017-2020]',
   'VX MT Petrol',
   'VX MT Petrol[2017-2020]']},
 'Hyundai': {'Aura': ['S 1.2 CNG'],
  'Creta': ['1.4 S[2015-2017]',
   '1.6 SX Plus AT Petrol[2015-2017]',
   '1.6 SX[2015-2017]',
   'E 1.5 Diesel',
   'E Plus 1.4 CRDI[2017-2018]',
   'E Plus 1.6 Petrol[2017-2018]',
   'EX 1.5 Petrol',
   'S 1.5 Petrol',
   'SX (O) 1.5 Diesel',
   'SX 1.5 Diesel[2020-2023]',
   'SX 1.5 Petrol',
   'SX 1.6 AT CRDi[2018-2019]',
   'SX 1.6 AT Petrol[2018-2019]',
   'SX 1.6 Petrol[2018-2019]',
   'SX Plus 1.6  Petrol[2017-2018]',
   'SX Plus 1.6 AT CRDI[2017-2018]'],
  'Elantra': ['SX (O) 2.0 AT'],
  'Elite i20': ['Asta 1.2',
   'Asta 1.2 (O)',
   'Asta 1.2[2014-2015]',
   'Asta 1.2[2017-2018]',
   'Magna 1.2',
   'Magna 1.2[2014-2015]',
   'Sportz 1.2',
   'Sportz 1.2[2014-2015]',
   'Sportz 1.2[2017-2018]',
   'Sportz 1.2[2019-2020]',
   'Sportz 1.4'],
  'Eon': ['Era +', 'Magna +'],
  'Grand i10': ['Asta 1.2 Kappa VTVT',
   'Asta AT 1.2 Kappa VTVT [2013-2016][2013-2017]',
   'Magna 1.2 Kappa VTVT',
   'Magna AT 1.2 Kappa VTVT',
   'Sportz (O) 1.2 Kappa VTVT [2017-2018]',
   'Sportz (O) AT 1.2 Kappa VTVT [2017-2018]',
   'Sportz 1.2 Kappa VTVT',
   'Sportz AT 1.2 Kappa VTVT'],
  'Santro': ['Sportz'],
  'Venue': ['S 1.2 Petrol',
   'SX (O) 1.0 Turbo iMT',
   'SX 1.0 Turbo',
   'SX 1.2 Petrol',
   'SX 1.5 CRDi',
   'SX Plus 1.0 Turbo DCT'],
  'Verna': ['i[2006-2010]'],
  'Xcent': ['E', 'SX'],
  'i10': ['Magna'],
  'i20 Active': ['1.2 S'],
  'i20': ['Magna 1.2[2012-2014]']},
 'Mahindra': {'Alturas G4': ['4WD AT'],
  'TUV300': ['T8', 'T8[2015-2019]'],
  'Thar': ['CRDe 4x4 AC[2014-2020]',
   'LX Convertible Petrol AT',
   'LX Hard Top Diesel AT',
   'LX Hard Top Diesel AT 4WD',
   'LX Hard Top Diesel AT 4WD [2023]',
   'LX Hard Top Diesel MT 4WD',
   'LX Hard Top Diesel MT RWD',
   'LX Hard Top Petrol AT',
   'LX Hard Top Petrol AT 4WD',
   'LX Hard Top Petrol MT'],
  'XUV300': ['W8 (O) 1.2 Petrol', 'W8 (O) 1.5 Diesel'],
  'XUV500': ['W10[2015-2018]',
   'W11',
   'W6[2011-2015]',
   'W6[2015-2018]',
   'W7',
   'W8[2011-2015]',
   'W9']},
 'Maruti Suzuki': {'Alto 800': ['LXi', 'Lx[2012-2016]', 'VXi'],
  'Baleno': ['Alpha 1.2[2015-2019]',
   'Alpha[2019-2022]',
   'Delta 1.2[2015-2019]',
   'Zeta 1.2[2015-2019]',
   'Zeta[2019-2022]'],
  'Brezza': ['LXi', 'VXi', 'ZXi', 'ZXi Plus'],
  'Celerio': ['VXi', 'VXi AMT', 'ZXi'],
  'Ciaz': ['Alpha 1.4 AT[2017-2018]',
   'Alpha Hybrid 1.5 AT [2018-2020]',
   'Alpha Hybrid 1.5 [2018-2020]',
   'VXi[2014-2017]',
   'ZXI+[2014-2017]',
   'ZXi[2014-2017]'],
  'Eeco': ['5 STR AC', '5 STR[2010-2022]'],
  'Ertiga': ['VDI SHVS[2015-2018]',
   'VXI[2015-2018]',
   'VXi',
   'VXi (O) CNG',
   'VXi CNG',
   'VXi[2018-2022]',
   'ZXi',
   'ZXi Plus',
   'ZXi[2018-2022]'],
  'Ignis': ['Delta 1.2 AMT', 'Delta 1.2 MT', 'Zeta 1.2 AMT', 'Zeta 1.2 MT'],
  'S-Cross': ['Zeta 1.3', 'Zeta 1.3[2014-2017]'],
  'S-Presso': ['VXi'],
  'Swift DZire': ['VDI[2011-2015]', 'VXI[2011-2015]'],
  'Swift': ['LXi',
   'VDi[2014-2018]',
   'VXi',
   'VXi AMT',
   'ZDi[2014-2018]',
   'ZXi',
   'ZXi Plus'],
  'Vitara Brezza': ['VDi[2016-2020]', 'ZDi[2016-2020]'],
  'Wagon R': ['LXI 1.0', 'LXI 1.0 CNG', 'VXI 1.0'],
  'XL6': ['Alpha AT Petrol',
   'Alpha MT Petrol',
   'Zeta AT Petrol',
   'Zeta MT Petrol']},
 'Tata': {'Altroz': ['XZ Petrol'],
  'Harrier': ['XT[2019-2023]', 'XZ[2019-2023]'],
  'Hexa': ['XT 4x2 7 STR', 'XTA 4x2 7 STR'],
  'Nano': ['Twist XT'],
  'Nexon': ['XM[2017-2020]', 'XM[2020-2023]', 'XZ[2017-2020]'],
  'Safari': ['XZ[2021-2023]'],
  'Tiago': ['Revotron XZA [2017-2019][2016-2020]',
   'XE',
   'XM',
   'XT',
   'XZ',
   'XZ Plus',
   'XZA'],
  'Tigor': ['XZ', 'XZ Plus']},
 'Toyota': {'Camry': ['Hybrid'],
  'Corolla Altis': ['G Petrol[2014-2017]',
   'G[2014-2017]',
   'VL AT Petrol[2014-2017]'],
  'Etios': ['GD', 'G[2010-2013]'],
  'Fortuner': ['2.8 4x2 MT[2016-2021]',
   '2.8 4x4 AT[2016-2021]',
   '3.0 4x2 AT[2012-2016]',
   '3.0 4x2 MT[2012-2016]',
   '4X2 AT 2.8 Diesel',
   '4X4 AT 2.8 Diesel'],
  'Glanza': ['E', 'V'],
  'Innova Crysta': ['2.4 VX 7 STR[2016-2020]',
   '2.4 ZX 7 STR[2016-2020]',
   '2.8 GX AT 7 STR [2016-2020][2016-2020]',
   '2.8 GX AT 8 STR [2016-2020][2016-2020]',
   '2.8 ZX AT 7 STR [2016-2020][2016-2020]',
   'GX 2.4 AT 7 STR[2020-2023]',
   'ZX 2.4 AT 7 STR[2020-2023]'],
  'Urban Cruiser': ['Premium Grade AT']}}

import streamlit as st
import joblib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# -----------------------------------------------------------------------------
# 1) Define Custom Transform Function
# -----------------------------------------------------------------------------
def log1p_transform(x):
    """
    Custom log1p transform function used in the model's preprocessing pipeline.
    """
    return np.log1p(x)

MODEL_PATH_CAT = 'catboost_price_model.joblib'
MODEL_PATH_CAT2 = 'catboost_model_of_5.joblib'
MODEL_PATH_XGB = 'XGB_price_model.joblib'
MODEL_PATH_DT = 'DT_price_model.joblib'

# Ensure this matches your saved pipeline's filename
DATASET_PATH = 'new_training_data.csv'

# Load the dataset with proper error handling
try:
    df = pd.read_csv(DATASET_PATH)
    required_columns = {'Make', 'Model', 'Variant', 'Age', 'Distance_numeric', 'Price_numeric'}
    if not required_columns.issubset(df.columns):
        missing = required_columns - set(df.columns)
        st.error(f"The dataset is missing required columns: {missing}")
        st.stop()
except FileNotFoundError:
    st.error(f"Dataset file not found at path: {DATASET_PATH}")
    st.stop()
except pd.errors.EmptyDataError:
    st.error("The dataset file is empty.")
    st.stop()
except pd.errors.ParserError:
    st.error("Error parsing the dataset file. Please check its format.")
    st.stop()
except Exception as e:
    st.error(f"An unexpected error occurred while loading the dataset: {e}")
    st.stop()

# -----------------------------------------------------------------------------
# 3) Helper Functions
# -----------------------------------------------------------------------------
def get_age_bracket(age):
    """
    Returns a label based on the age bucket.
    """
    if age < 3:
        return '0-3'
    elif age < 5:
        return '3-5'
    elif age < 10:
        return '5-10'
    elif age < 15:
        return '10-15'
    else:
        return '15+'

def get_mileage_bracket(mileage):
    """
    Returns a label based on the odometer bucket.
    """
    if mileage < 30000:
        return '0-30k'
    elif mileage < 60000:
        return '30k-60k'
    elif mileage < 100000:
        return '60k-100k'
    elif mileage < 150000:
        return '100k-150k'
    else:
        return '150k+'

def get_nearest_age_subset(df, make, model, variant, age, min_samples=5, max_delta=5):
    """
    Selects a subset of the dataframe based on the nearest age group.
    Starts with the same age, then expands the range by ±1, ±2, etc., until
    at least min_samples are found or max_delta is reached.
    """
    subset = df[
        (df['Make'] == make) &
        (df['Model'] == model) &
        (df['Variant'] == variant)
    ]

    if subset.empty:
        return subset  # Empty subset

    max_age = subset['Age'].max()

    # If input age exceeds max_age, return the entire subset to handle depreciation
    if age > max_age:
        return subset

    # Initialize delta
    delta = 0
    while delta <= max_delta:
        age_min = age - delta
        age_max = age + delta
        # Ensure age_min is not negative
        age_min = max(age_min, 0)
        subset_age = subset[
            (subset['Age'] >= age_min) &
            (subset['Age'] <= age_max)
        ]
        if len(subset_age) >= min_samples:
            return subset_age
        delta += 1

    # If not enough samples even after max_delta, return the closest possible subset
    return subset[
        (subset['Age'] >= max(age - max_delta, 0)) &
        (subset['Age'] <= min(age + max_delta, max_age))
    ]


def apply_guardrails(age, distance, fuel_type, city, avg_prediction, df_subset, depreciation_rate=0.02, min_floor=50000, appreciation_rate=0.05):
    """
    Enhanced guardrails with:
    - Handling for single data point cases
    - Price appreciation for cars newer than dataset
    - Depreciation based on bottom 25th percentile for cars older than dataset
    - Dynamic age-based pricing
    """
    # Enhanced regulatory constraints for Delhi NCR
    if (fuel_type.lower() == 'diesel' and age > 10 and 
        city.lower() in ['delhi', 'gurgaon', 'noida']):
        return None
    
    if (fuel_type.lower() == 'petrol' and age > 15 and 
        city.lower() in ['delhi', 'gurgaon', 'noida']):
        return None

    # Add age brackets to subset
    df_subset = df_subset.copy()
    df_subset['Age_Bracket'] = df_subset['Age'].apply(get_age_bracket)
    
    min_age_subset = df_subset['Age'].min()
    max_age_subset = df_subset['Age'].max()

    # Initialize clamped_price with a default value
    clamped_price = avg_prediction

    # Handle cars newer than dataset
    if age < min_age_subset:
        input_bracket = get_age_bracket(age)
        bracket_order = ['0-3', '3-5', '5-10', '10-15', '15+']
        
        # Find the next available age bracket in the dataset
        next_bracket = None
        for bracket in bracket_order[bracket_order.index(input_bracket)+1:]:
            if bracket in df_subset['Age_Bracket'].unique():
                next_bracket = bracket
                break
        
        if next_bracket:
            next_subset = df_subset[df_subset['Age_Bracket'] == next_bracket]
            if not next_subset.empty:
                # Use 75th percentile of next bracket as base price
                if len(next_subset) >= 5:
                    base_price = next_subset['Price_numeric'].quantile(0.75)
                else:
                    # If fewer than 5 samples, use the mean or single available price
                    base_price = next_subset['Price_numeric'].mean()
                
                # Calculate the number of years below the minimum age
                years_below = min_age_subset - age
                
                # Apply appreciation for each year below the minimum age
                clamped_price = base_price * ((1 + appreciation_rate) ** years_below)
        else:
            # If no next bracket is found, use the average prediction
            clamped_price = avg_prediction

    # Adaptive percentile clamping for cars within dataset age range
    elif age <= max_age_subset and len(df_subset) >= 1:  # Handle single data point
        if len(df_subset) >= 5:
            # Dynamic percentile selection based on sample size
            lower_p = 25 if len(df_subset) < 20 else 5
            upper_p = 75 if len(df_subset) < 20 else 95
            
            p_low, p_high = np.percentile(df_subset['Price_numeric'], [lower_p, upper_p])
            clamped_price = np.clip(avg_prediction, p_low*0.95, p_high*1.05)
        else:
            # If fewer than 5 samples, use the mean or single available price
            clamped_price = df_subset['Price_numeric'].mean()

    # Smart depreciation for older cars
    if age > max_age_subset and len(df_subset) > 0:
        # Use bottom 25th percentile of the last age bracket as base price
        last_bracket_subset = df_subset[df_subset['Age'] == max_age_subset]
        if not last_bracket_subset.empty:
            if len(last_bracket_subset) >= 5:
                base_price = last_bracket_subset['Price_numeric'].quantile(0.25)  # Bottom 25th percentile
            else:
                # If fewer than 5 samples, use the mean or single available price
                base_price = last_bracket_subset['Price_numeric'].mean()
            
            # Dynamic depreciation rates
            if fuel_type.lower() == 'diesel' and city.lower() in ['delhi', 'gurgaon', 'noida']:
                depreciation_rate = 0.07  # Higher depreciation for diesel in NCR
            elif fuel_type.lower() == 'petrol' and age > 15:
                depreciation_rate = 0.05
            
            # Calculate years beyond the maximum age
            years_beyond = age - max_age_subset
            
            # Apply depreciation
            clamped_price = base_price * ((1 - depreciation_rate) ** years_beyond)
        else:
            # Fallback to average prediction if no data in the last bracket
            clamped_price = avg_prediction

    # Final price adjustments
    final_price = max(clamped_price, min_floor)
    
    # # Market consistency check
    # if len(df_subset) > 0:
    #     market_avg = df_subset['Price_numeric'].mean()
    #     if abs(final_price - market_avg) > (market_avg * 0.5):  # More than 50% deviation
    #         final_price = market_avg  # Fallback to market average
    
    return final_price

def find_closest_cars(make, model, variant, age, distance, df):
    """
    Returns up to 10 closest cars in the dataset based on the same M-M-V.
    """
    filtered = df[
        (df['Make'] == make) &
        (df['Model'] == model) &
        (df['Variant'] == variant)
    ]

    if filtered.empty:
        return pd.DataFrame()

    filtered = filtered.copy()
    filtered['Age_Diff'] = abs(filtered['Age'] - age)
    filtered['Odom_Diff'] = abs(filtered['Distance_numeric'] - distance)
    closest_cars = filtered.sort_values(by=['Age_Diff', 'Odom_Diff']).head(10)
    return closest_cars[['Make', 'Model', 'Variant', 'Age', 'Distance_numeric', 'Price_numeric']]

# -----------------------------------------------------------------------------
# 4) Streamlit Application Layout and Inputs
# -----------------------------------------------------------------------------
st.title("Used Car Price Prediction App with M-M-V Guardrails")
st.write("""
This application predicts the price of a used car based on various features.
**Guardrails** are applied per Make-Model-Variant (M-M-V) subset to clamp unrealistic values.
For cars older than the dataset's maximum age for their M-M-V, a constant depreciation rate is applied.
""")

# Sidebar Inputs
st.sidebar.header("Enter Car Details")

# Define the hierarchical dictionary for Make, Model, Variant
# (Ensure this matches your dataset and model training)
# Example structure, replace with your actual data
# Select Make
selected_make = st.sidebar.selectbox("Select Make", options=list(d.keys()) if d else [])

# Select Model based on Make
if selected_make:
    selected_model = st.sidebar.selectbox("Select Model", options=list(d[selected_make].keys()))
else:
    selected_model = None

# Select Variant based on Model
if selected_model:
    selected_variant = st.sidebar.selectbox("Select Variant", options=d[selected_make][selected_model])
else:
    selected_variant = None

# Select City
selected_city = st.sidebar.selectbox(
    "City",
    [
        'Ahmedabad', 'Bangalore', 'Chennai', 'Gurgaon', 'Hyderabad', 'Kolkata',
        'Pune', 'Delhi', 'Panchkula', 'Ludhiana', 'Kharar', 'Coimbatore',
        'Noida', 'Ghaziabad', 'Lucknow', 'Mumbai', 'Thane', 'Mohali',
        'Kharagpur', 'Chandigarh', 'Ambala', 'Navi', 'Faridabad', 'Meerut',
        'Sangli', 'Surat', 'Mysore', 'Gulbarga', 'Ranga', 'Vadodara', 'Howrah'
    ]
)

# Select Transmission
selected_transmission = st.sidebar.selectbox("Transmission", ['Manual', 'Automatic'])

# Select Fuel Type
selected_fuel_type = st.sidebar.selectbox("Fuel Type", ['Petrol', 'Diesel', 'CNG'])

# Numeric Inputs
age = st.sidebar.number_input("Age (years)", min_value=0, max_value=50, value=5, step=1)
distance = st.sidebar.number_input("Odometer Reading (km)", min_value=0, max_value=500000, value=40000, step=1000)

# Dynamic ± range slider
range_percentage = st.sidebar.slider("Confidence Range (%)", 1, 20, 5)

# -----------------------------------------------------------------------------
# 5) Prediction Function
# -----------------------------------------------------------------------------
def predict_price_from_multiple_models(age, distance, make, car_model, variant, city, transmission, fuel_type):
    """
    Get raw model predictions from multiple models.
    """
    # Avoid division by zero
    distance_per_year = (distance / (age + 1)) if (age + 1) else distance

    input_data = pd.DataFrame([{
        'Make': make,
        'Model': car_model,
        'Transmission': transmission,
        'Fuel Type': fuel_type,
        'City': city,
        'Distance_numeric': distance,
        'Age': age,
        'Distance_per_year': np.round(distance_per_year, 2),
        'Variant': variant
    }])

    predictions = {}
    models = {
        "CatBoost": MODEL_PATH_CAT,
        "Cat2": MODEL_PATH_CAT2,
        "XGBoost": MODEL_PATH_XGB,
        "Decision Tree": MODEL_PATH_DT,
    }

    for model_name, model_path in models.items():
        try:
            model = joblib.load(model_path)
            prediction = model.predict(input_data)
            predictions[model_name] = prediction[0]
        except Exception as e:
            st.error(f"Error during prediction with {model_name}: {e}")

    return predictions

# -----------------------------------------------------------------------------
# 6) Main Button: Generate Prediction & Apply Guardrails
# -----------------------------------------------------------------------------
if st.button("Predict Price"):
    if not all([selected_make, selected_model, selected_variant, selected_city, selected_transmission, selected_fuel_type]):
        st.error("Please fill in all the car details.")
    else:
        # Get predictions from different models
        raw_predictions = predict_price_from_multiple_models(
            age=age,
            distance=distance,
            make=selected_make,
            car_model=selected_model,  # Renamed parameter to avoid shadowing
            variant=selected_variant,
            city=selected_city,
            transmission=selected_transmission,
            fuel_type=selected_fuel_type
        )

        if not raw_predictions:
            st.error("An error occurred during prediction. Please check your inputs.")
        else:
            # Calculate the average prediction
            avg_prediction = np.mean(list(raw_predictions.values()))
            st.success(f"Average Predicted Price: ₹{round(avg_prediction)}")

            # Apply guardrails on the average prediction
            subset_mmv = get_nearest_age_subset(
                df=df,
                make=selected_make,
                model=selected_model,
                variant=selected_variant,
                age=age,
                min_samples=5,   # Minimum required samples
                max_delta=5      # Maximum age difference to consider
            )

            if subset_mmv.empty:
                st.error("No data available for the selected Make-Model-Variant.")
                st.success(f"Average Predicted Price: ₹{round(avg_prediction)}")
                # Even if subset is empty, you might still want to display the raw average
                # Depending on your requirements
                # Optionally, you can decide to stop here
            else:
                # Apply guardrails to the average prediction
                guarded_price = apply_guardrails(
                    age=age,
                    distance=distance,
                    fuel_type=selected_fuel_type,
                    city=selected_city,
                    avg_prediction=avg_prediction,
                    df_subset=subset_mmv,
                    depreciation_rate=0.04,  # 4% depreciation rate per year beyond max age
                    min_floor=40000           # ₹40,000 minimum floor
                )

                if guarded_price is None:
                    st.error("Cannot predict a valid price under current regulations/constraints.")
                else:
                    st.success(f"Guarded Average Predicted Price: ₹{round(guarded_price)}")

                    # Calculate dynamic ± range for the guarded price
                    lower_bound = guarded_price * (1 - range_percentage / 100)
                    upper_bound = guarded_price * (1 + range_percentage / 100)
                    st.write(f"Price Range (±{range_percentage}%): ₹{round(lower_bound)} - ₹{round(upper_bound)}")

                    similar_cars = find_closest_cars(selected_make, selected_model, selected_variant, age, distance, df)
                    if similar_cars.empty:
                        st.write("No similar cars found in the dataset for this M-M-V.")
                    else:
                        st.write("Closest Cars (based on Age & Odometer):")
                        st.dataframe(similar_cars)



                    # Optional: Plot Age vs. Price for M-M-V subset with only the average point
                    if not subset_mmv.empty:
                        fig, ax = plt.subplots(figsize=(8, 6))

                        # Scatter plot for dataset cars (same M-M-V)
                        mmv_subset = df[
                            (df['Make'] == selected_make) & 
                            (df['Model'] == selected_model) & 
                            (df['Variant'] == selected_variant)
                        ]
                        ax.scatter(
                            mmv_subset['Age'], 
                            mmv_subset['Price_numeric'], 
                            color='blue',  
                            alpha=0.5, 
                            label='Dataset Cars (Same M-M-V)'
                        )

                        # Plot the guarded average prediction
                        ax.scatter(
                            age, 
                            guarded_price, 
                            color='purple', 
                            s=200, 
                            zorder=5, 
                            marker='*', 
                            label='Guarded Average Prediction'
                        )

                        # Shade the ± range
                        ax.fill_between(
                            x=[age - 1, age + 1],  # Adjust x-range around the age
                            y1=lower_bound,
                            y2=upper_bound,
                            color='lightgreen', 
                            alpha=0.2,
                            label=f"±{range_percentage}% Range"
                        )

                        ax.set_xlabel("Age (Years)")
                        ax.set_ylabel("Price (₹)")
                        ax.set_title(f"Age vs. Price for {selected_make} {selected_model} {selected_variant}")
                        ax.legend()
                        st.pyplot(fig)
                    else:
                        st.write("No data to plot for this M-M-V subset.")
